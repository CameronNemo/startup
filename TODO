High Priority:

 * The "Event Expression"/"State" code isn't complete yet, and has atomicity
   issues.
   * Using start_on/stop_on to store referenced events for the environment
     isn't going to work; it means that it's trivial for jobs to be re-started
     or re-stopped by just one event rather than the whole sequence.  As soon
     as the sequence is complete, we should transfer the events that matter to
     a "state instance" and use *that* for the environment.

     * This works for the "start state", but not for the "stop state": I
       actually don't mind this on the whole, because it means the
       pre-stop/post-stop will actually get the environment of the start
       bits of the job as well.  It's not perfect though, because we still
       need to somehow fail the stop events in the event that there's an
       error stopping (err, is this ever true?) even if not, we still need
       to unblock the buggers.

   * All of this doesn't sit well with restarting; for example, what if a getty
     instance is started by tty-added tty1 ... tty-removed tty1, and then the
     same event happens again?  possibly while the instance is still running
     or stopping!

     * Maybe states/jobs should specify what makes an instance unique - and
       this becomes the instance arguments?

     * See also instance names.

     * This needs event variables for keys!  If we have the "environment"
       of a job, this starts to become possible.

   * One way would be to always combine an EventOperator set with an
     "EventState" when the operator becomes true, the current values are
     copied into the EventState and the operator tree automatically reset. 
     You would then unblock and unreference the EventState part, not the
     EventOperator part (which is always blocked or empty).

     * This makes the combined thing atomic and repeatable.

     * We'd need one for both start and stop (since we'd need to know the state
       that caused us to stop).

     * We'd have to reset the operator and state if we're started manually or
       stopped manually?  This isn't true right now, and I'm not sure what the
       desired result is.

     * Event States themselves need this for the instances, since if we permit
       instances to restart, we do need to track their "start" events not to
       mention their "stop" events.

   * Make sure that event subscribers get notified of the job event, but
     don't get notified twice!

 * Configuration reloading needs to happen with an initctl command;
   we also need to support re-exec via initctl as well.

 * Restore serialisation of state between upstart processes.  Having made
   the structures in memory more sane, this should be easier again, as
   long as we send things in this order:

    * Event queue
    * Job hash (referencing cause and blocked events by id, also need to
      ensure we handle instance jobs proeprly)
    * NotifySubscription list (which references both events by id and jobs
      by name [or id])
   
   I want to use the IPC protocol for this, since it's somewhat stable
   now.  Handing off will still use the "fork a child, exec in the parent"
   model, except for the following.

    * Leave the control socket open, clear the cloexec flag, and pass its
      file descriptor number to the new init process.
    * In the child, close the control socket we had open and open an
      ordinary socket; blocking-write the information to that and then die.

 * Handling of utmp and wtmp needs to be somewhat better.
   - common function to read/write to utmp and wtmp
   - should be able to read current runlevel (as runlevel does right now)
   - should be able to set current runlevel (as runlevel does right now)
   - move runlevel setting code into telinit before it emits the event,
     which should include RUNLEVEL and PREVLEVEL in the environment
   - shutdown should write a shutdown entry
   - reboot should check the current runlevel, and exec shutdown based on 
     that, as well as -f
   - reboot should write the wtmp shutdown record
   - somehow on startup we should write the reboot record as early as we
     can
   - init needs to grow "utmp XXX", which maintains INIT_PROCESS and
     DEAD_PROCESS entries for the given ut_id (3 chars max), used for getty


Medium Priority:

 * Iterating through every Job's start and stop events is messy; we should
   have some kind of match lookup table to make it easier.

 * Likewise iterating through all the Jobs to find a pid is messy; we
   should have a lookup table for these too.

 * When spawning a process, keep a pipe open (but mark it FD_CLOEXEC); if
   we encounter any problems write the error code to this pipe and die.
   Then from above, we can read this pipe to determine whether the job
   failed before or after the exec.  (Might be a cleaner way to do this).

 * Interval for respawn limit should be settable to "ever" to support maximum
   possible number of restarts before the job is disabled.  Though how does
   one reset it?


Low Priority:

 * If environment variables don't have an = in them, copy that variable
   from init's environment (default PATH, TERM).  On the subject of
   process_setup_environment, it's getty very messy; it's about time it
   got cleaned up -- and maybe don't use putenv/setenv since they're a
   little strange.

 * Need to add dependencies to jobs, which are files that must exist before
   the job can be started (because Debian/Ubuntu like to litter config files
   like jobs)

 * process_setup_console is due for an overhaul as well; especially if
   we want to be able to pass file descriptors in.  Am somewhat tempted
   to add a magic CONSOLE_DEFAULT option which tries fd, logging, null,
   etc.  and use CONSOLE_LOGGED to mean "die if logd isn't around".

 * We always want /dev/fd/NNN to be /dev/fd/3, we should have some way
   to instruct process_spawn to do that.

 * We may need to KILL scripts, e.g. post-start; especially when the goal
   changes.  Or perhaps just after a timeout?

 * May need a way to force ignoring of the KILL signal, and assuming that
   a job that won't die really has.

 * Replace logd raise/wait/kill interlock with a pipe-based one?

 * Replace logd with something else that's more standard in the system,
   and just use a normal API to communicate with it.

 * logd is currently disabled because of the problem where it goes away,
   and the scripts being run end up vanishing because they can't write
   data.


Unfinished Features:

 * Get the LANG environment variable somehow.


Future Features:

 * Instances; sometimes you want a given number of instances running, with
   each one being able to determine which instance it was (maybe file events
   is the way to solve this?)

 * Per-user services; will need to use PAM to set up the session.
   We want to do this for "root-user services" but not for jobs/tasks

 * Passing of environment and file descriptors from event over control
   socket.

 * Register jobs over the control socket, ideal way is to register some kind
   of automatic source and attach them to that.

 * Temporal events ("15m after startup")

 * Scheduled times ("every day at 3:00")

 * Load average checking, maybe have separate CPU, Network and I/O
   stats?

 * Actions: "reload" and optional replacements for "stop", "start", etc.

   This is mostly just a matter of deciding policy for when they can be run,
   and adding "user processes" onto the end of the job->process array.

 * Alternative script interpreters; "start script python".

   Would be done by making script a char *, and putting the interpreter into
   command?

 * Resources, "uses cpu 1.0" -- where cpu has a defined max (default 1.0);
   which state do we keep it in while it's waiting?

 * Watershed jobs (this actually might apply to events, since you might
   want to try starting again if a particular event has come in since you
   were last started)
