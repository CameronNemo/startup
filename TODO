High Priority:

 * Logging of processes.  Involves writing logd and putting the
   opposite hooks to it in init.

    - logd will print these in the cute manner by subscribing to jobs
    - init opens socket, writes the job name, etc. and dups that to
      stdout/stderr (stdin can be null)
    - writes to /var/log/boot or caches in a memory buffer, make it
      look like syslog
    - run other commands like usplash_write, spdsay, etc.

 * sulogin (on stalled)


 * Configuration files can be deleted, need to do something with the
   job at that point (stop it and delete it)

 * Configuration files can be moved.

 * Move config file parsing code into libupstart and just have a stanza
   callback function (so we can use it for all config file stuff)


 * cfg_watch_dir needs testing, as does cfg_watcher

 * test event_queue_run

 * fix up and document better the console setup stuff we stole


Unfinished Features:

 * Handle locating the pid for a spawned daemon, use an inotify watch
   on the pid file or scan /proc.

 * Deal with instances, spawning and freeing of them.  Will need to be
   hooked into job_find_by_name so that provides only the parent, and
   another way to find other instances.  job_find_other_instance ()
   which takes an existing job, iterates for the same name?

 * Get the LANG environment variable somehow.


Future Features:

 * Per-user services; will need to use PAM to set up the session.
   We want to do this for "root-user services" but not for jobs/tasks

 * Passing of environment and file descriptors from event over control
   socket.

 * Register services over the control socket.

 * Temporal events ("15m after startup")

 * Scheduled times ("every day at 3:00")

 * Load average checking, maybe have separate CPU, Network and I/O
   stats?


Musings and Feedback:

 * Some magic could be hidden through special commands.  It might be
   common for example to depend on a job to be running, start when it
   enters running and stop when it leaves running.

 * We could replace release_depends with an implicit listen on
   "foo running".  Though how would we know to send the dependency
   event or equivalent?


 * "depends" in its current form was considered confusing, suggested
   rename was "wait for"


 * script/process doesn't know what event was triggered.  Put it in
   env?

 * "end script" too verbose?

 * how do you kill a runaway script?  timeouts?  kill?


 * Would be nice if we could use the "spawned" state for other things
   daemon-related too, like having a script that indicates whether the
   daemon is actually running yet or not -- useful for "not running
   until it listens on port 80"
