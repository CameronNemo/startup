Code Cleanup:

 * Ensure all functions that call an allocating function are tested with
   TEST_ALLOC_FAIL

 * Ensure all functions that allocate and return memory have the
   warn_unused_result and malloc attributes

 * Ensure all functions that return a raised error have the warn_unused_result
   attribute.

 * Functions that only return a status to indicate a non-raised error do not
   need attributes (it's ok to ignore the error)

 * cfg_watch_dir needs testing

 * test event_queue_run needs testing


High Priority:

 * sort out the message types into groups, etc.

 * add a new information exchange message and use that for reexec, move
   all the reexec stuff into one place

 * Configuration files can be deleted, need to do something with the
   job at that point (stop it and delete it)

 * if environment variables don't have an = in them, copy that variable
   from init's environment (default PATH, TERM)

 * use execve, not putenv/setenv!


Medium Priority:


Low Priority:

 * consider renaming daemon to "forks" or similar?

 * ban using respawn/daemon as a shortcut?

 * replace logd raise/wait/kill interlock with a pipe-based one?

 * replace logd with something else that's more standard in the system,
   and just use a normal API to communicate with it.


Unfinished Features:

 * Handle locating the pid for a spawned daemon, use an inotify watch
   on the pid file or scan /proc.

 * Deal with instances, spawning and freeing of them.  Will need to be
   hooked into job_find_by_name so that provides only the parent, and
   another way to find other instances.  job_find_other_instance ()
   which takes an existing job, iterates for the same name?

 * Get the LANG environment variable somehow.


Future Features:

 * Per-user services; will need to use PAM to set up the session.
   We want to do this for "root-user services" but not for jobs/tasks

 * Passing of environment and file descriptors from event over control
   socket.

 * Register services over the control socket.

 * Temporal events ("15m after startup")

 * Scheduled times ("every day at 3:00")

 * Load average checking, maybe have separate CPU, Network and I/O
   stats?

 * Actions: "reload" and optional replacements for "stop", "start", etc.

 * we may need to KILL scripts, e.g. post-start

 * If we can't KILL things, we shouldn't ignore that, we should treat
   that as a failure and adjust the job again so it still shows up as
   running

 * force option?  ensures things are KILLed and failure to KILL
   ignored?

 * scripts should also have a timeout
