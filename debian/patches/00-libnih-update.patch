=== modified file 'ChangeLog.nih'
--- ChangeLog.nih	2007-02-09 17:30:41 +0000
+++ ChangeLog.nih	2007-02-11 17:01:06 +0000
@@ -1,3 +1,37 @@
+2007-02-11  Johan Kiviniemi  <johan@kiviniemi.name>
+
+	* nih/hash.h (NIH_HASH_FOREACH, NIH_HASH_FOREACH_SAFE): Added missing
+	parenthesis around hash, in case it's a complicated expression with
+	unsurprising precedence results.
+
+2007-02-11  Scott James Remnant  <scott@netsplit.com>
+
+	* nih/config.c (nih_config_skip_whitespace): It turns out that when
+	parsing, it's often useful to skip any whitespace while retaining the
+	"step over newlines" behaviour.  Seperate it out into its own 
+	function.
+	(nih_config_next_token): Call the new function.
+	* nih/config.h: Add prototype.
+	* nih/tests/test_config.c (test_skip_whitespace): Check the function
+
+	* nih/config.c: Remove macro definitions
+	* nih/config.h: and make them public instead
+	* nih/tests/test_config.c: Use macros.
+
+	* nih/config.c (nih_config_next_token): Strange hybrid function,
+	it behaves like next_arg() but accepts the same arguments as token();
+	it skips whitespace, but only if the initial whitespace character is
+	in the delim argument.
+	(nih_config_next_arg): This becomes a wrapper around next_token.
+	* nih/config.h: Add prototype.
+	* nih/tests/test_config.c (test_next_token): Check the new function.
+
+	* nih/config.c (nih_config_next_token): Rename to nih_config_token,
+	since this doesn't behave like the next_arg() function, and we want
+	a similar token function that behaves like that.
+	* nih/config.h: Update.
+	* nih/tests/test_config.c (test_next_token): Rename and update.
+
 2007-02-09  Scott James Remnant  <scott@netsplit.com>
 
 	* nih/hash.h (NIH_HASH_FOREACH_SAFE): Oops, s/list/hash/

=== modified file 'nih/config.c'
--- nih/config.c	2007-02-06 12:44:12 +0000
+++ nih/config.c	2007-02-11 16:28:57 +0000
@@ -39,30 +39,6 @@
 #include <nih/errors.h>
 
 
-/**
- * WS:
- *
- * Definition of what characters we consider whitespace.
- **/
-#define WS " \t\r"
-
-/**
- * CNL:
- *
- * Definition of what characters nominally end a line; a comment start
- * character or a newline.
- **/
-#define CNL "#\n"
-
-/**
- * CNLWS:
- *
- * Defintion of what characters nominally separate tokens.
- **/
-#define CNLWS " \t\r#\n"
-
-
-
 /* Prototypes for static functions */
 static ssize_t          nih_config_block_end  (const char *file, size_t len,
 					       size_t *lineno, size_t *pos,
@@ -107,7 +83,7 @@
 	nih_assert (file != NULL);
 
 	p = (pos ? *pos : 0);
-	if ((p < len) && (! strchr (CNL, file[p]))) {
+	if ((p < len) && (! strchr (NIH_CONFIG_CNL, file[p]))) {
 		return TRUE;
 	} else {
 		return FALSE;
@@ -116,7 +92,7 @@
 
 
 /**
- * nih_config_next_token:
+ * nih_config_token:
  * @file: file or string to parse,
  * @len: length of @file,
  * @pos: offset within @file,
@@ -125,7 +101,7 @@
  * @delim: characters to stop on,
  * @dequote: remove quotes and escapes.
  *
- * Extracts a single token from @file which is stopped when any character
+ * Parses a single token from @file which is stopped when any character
  * in @delim is encountered outside of a quoted string and not escaped
  * using a backslash.
  *
@@ -154,13 +130,13 @@
  * or negative value on raised error.
  **/
 ssize_t
-nih_config_next_token (const char *file,
-		       size_t      len,
-		       size_t     *pos,
-		       size_t     *lineno,
-		       char       *dest,
-		       const char *delim,
-		       int         dequote)
+nih_config_token (const char *file,
+		  size_t      len,
+		  size_t     *pos,
+		  size_t     *lineno,
+		  char       *dest,
+		  const char *delim,
+		  int         dequote)
 {
 	size_t  p, ws = 0, nlws = 0, qc = 0, i = 0;
 	ssize_t ret;
@@ -208,7 +184,7 @@
 				if (lineno)
 					(*lineno)++;
 				continue;
-			} else if (strchr (WS, file[p])) {
+			} else if (strchr (NIH_CONFIG_WS, file[p])) {
 				ws++;
 				continue;
 			}
@@ -217,7 +193,7 @@
 			isq = TRUE;
 		} else if (strchr (delim, file[p])) {
 			break;
-		} else if (strchr (WS, file[p])) {
+		} else if (strchr (NIH_CONFIG_WS, file[p])) {
 			ws++;
 			continue;
 		}
@@ -294,17 +270,20 @@
 }
 
 /**
- * nih_config_next_arg:
+ * nih_config_next_token:
  * @parent: parent of returned argument,
  * @file: file or string to parse,
  * @len: length of @file,
  * @pos: offset within @file,
- * @lineno: line number.
+ * @lineno: line number,
+ * @delim: characters to stop on,
+ * @dequote: remove quotes and escapes.
  *
- * Extracts a single argument from @file, a dequoted token that is stopped
- * on any comment, space or newline character that is not quoted or escaped
- * with a backslash.  Any whitespace after the argument is also consumed,
- * but not returned, including that with escaped newlines within it.
+ * Extracts a single token from @file which is stopped when any character
+ * in @delim is encountered outside of a quoted string and not escaped
+ * using a backslash.  If @delim contains any whitespace character, then
+ * all whitespace after the token is also consumed, but not returned,
+ * including that with escaped newlines within it.
  *
  * @file may be a memory mapped file, in which case @pos should be given
  * as the offset within and @len should be the length of the file as a
@@ -317,20 +296,25 @@
  * If @lineno is given it will be incremented each time a new line is
  * discovered in the file.
  *
+ * If you also want quotes to be removed and escaped characters to be
+ * replaced with the character itself, set @dequote to TRUE.
+ *
  * If @parent is not NULL, it should be a pointer to another allocated
  * block which will be used as the parent for this block.  When @parent
  * is freed, the returned block will be freed too.  If you have clean-up
  * that would need to be run, you can assign a destructor function using
  * the nih_alloc_set_destructor() function.
  *
- * Returns: the argument found or NULL on raised error.
+ * Returns: the token found or NULL on raised error.
  **/
 char *
-nih_config_next_arg (const void *parent,
-		     const char *file,
-		     size_t      len,
-		     size_t     *pos,
-		     size_t     *lineno)
+nih_config_next_token (const void *parent,
+		       const char *file,
+		       size_t      len,
+		       size_t     *pos,
+		       size_t     *lineno,
+		       const char *delim,
+		       int         dequote)
 {
 	size_t   p, arg_start, arg_end;
 	ssize_t  arg_len;
@@ -340,8 +324,8 @@
 
 	p = (pos ? *pos : 0);
 	arg_start = p;
-	arg_len = nih_config_next_token (file, len, &p, lineno,
-					 NULL, CNLWS, TRUE);
+	arg_len = nih_config_token (file, len, &p, lineno,
+				    NULL, delim, dequote);
 	arg_end = p;
 
 	if (arg_len < 0) {
@@ -352,38 +336,15 @@
 		goto finish;
 	}
 
-	/* Skip any amount of whitespace between them, we also need to
-	 * detect an escaped newline here.
-	 */
-	while (p < len) {
-		if (file[p] == '\\') {
-			/* Escape character, only continue scanning if
-			 * the next character is newline
-			 */
-			if ((len - p > 1) && (file[p + 1] == '\n')) {
-				p++;
-			} else {
-				break;
-			}
-		} else if (! strchr (WS, file[p])) {
-			break;
-		}
-
-		if (file[p] == '\n')
-			if (lineno)
-				(*lineno)++;
-
-		/* Whitespace characer */
-		p++;
-	}
+	nih_config_skip_whitespace (file, len, &p, lineno);
 
 	/* Copy in the new token */
 	arg = nih_alloc (parent, arg_len + 1);
 	if (! arg)
 		nih_return_system_error (NULL);
 
-	if (nih_config_next_token (file + arg_start, arg_end - arg_start, NULL,
-				   NULL, arg, CNLWS, TRUE) < 0)
+	if (nih_config_token (file + arg_start, arg_end - arg_start, NULL,
+			      NULL, arg, delim, dequote) < 0)
 		goto finish;
 
 finish:
@@ -394,6 +355,51 @@
 }
 
 /**
+ * nih_config_next_arg:
+ * @parent: parent of returned argument,
+ * @file: file or string to parse,
+ * @len: length of @file,
+ * @pos: offset within @file,
+ * @lineno: line number.
+ *
+ * Extracts a single argument from @file, a dequoted token that is stopped
+ * on any comment, space or newline character that is not quoted or escaped
+ * with a backslash.  Any whitespace after the argument is also consumed,
+ * but not returned, including that with escaped newlines within it.
+ *
+ * @file may be a memory mapped file, in which case @pos should be given
+ * as the offset within and @len should be the length of the file as a
+ * whole.
+ *
+ * If @pos is given then it will be used as the offset within @file to
+ * begin (otherwise the start is assumed), and will be updated to point
+ * to @delim or past the end of the file.
+ *
+ * If @lineno is given it will be incremented each time a new line is
+ * discovered in the file.
+ *
+ * If @parent is not NULL, it should be a pointer to another allocated
+ * block which will be used as the parent for this block.  When @parent
+ * is freed, the returned block will be freed too.  If you have clean-up
+ * that would need to be run, you can assign a destructor function using
+ * the nih_alloc_set_destructor() function.
+ *
+ * Returns: the argument found or NULL on raised error.
+ **/
+char *
+nih_config_next_arg (const void *parent,
+		     const char *file,
+		     size_t      len,
+		     size_t     *pos,
+		     size_t     *lineno)
+{
+	nih_assert (file != NULL);
+
+	return nih_config_next_token (parent, file, len, pos, lineno,
+				      NIH_CONFIG_CNLWS, TRUE);
+}
+
+/**
  * nih_config_next_line:
  * @file: file or string to parse,
  * @len: length of @file,
@@ -435,6 +441,63 @@
 	}
 }
 
+
+/**
+ * nih_config_skip_whitespace:
+ * @file: file or string to parse,
+ * @len: length of @file,
+ * @pos: offset within @file,
+ * @lineno: line number.
+ *
+ * Skips an amount of whitespace and finds either the next token or the end
+ * of the current line in @file.  Escaped newlines within the whitespace
+ * are treated as whitespace.
+ *
+ * @file may be a memory mapped file, in which case @pos should be given
+ * as the offset within and @len should be the length of the file as a
+ * whole.
+ *
+ * @pos is used as the offset within @file to begin, and will be updated
+ * to point to past the end of the line or file.
+ *
+ * If @lineno is given it will be incremented each time a new line is
+ * discovered in the file.
+ **/
+void
+nih_config_skip_whitespace (const char *file,
+			    size_t      len,
+			    size_t     *pos,
+			    size_t     *lineno)
+{
+	nih_assert (file != NULL);
+	nih_assert (pos != NULL);
+
+	/* Skip any amount of whitespace between them, we also need to
+	 * detect an escaped newline here.
+	 */
+	while (*pos < len) {
+		if (file[*pos] == '\\') {
+			/* Escape character, only continue scanning if
+			 * the next character is newline
+			 */
+			if ((len - *pos > 1) && (file[*pos + 1] == '\n')) {
+				(*pos)++;
+			} else {
+				break;
+			}
+		} else if (! strchr (NIH_CONFIG_WS, file[*pos])) {
+			break;
+		}
+
+		if (file[*pos] == '\n')
+			if (lineno)
+				(*lineno)++;
+
+		/* Whitespace characer */
+		(*pos)++;
+	}
+}
+
 /**
  * nih_config_skip_comment:
  * @file: file or string to parse,
@@ -614,14 +677,14 @@
 	 */
 	p = (pos ? *pos : 0);
 	cmd_start = p;
-	cmd_len = nih_config_next_token (file, len, &p, lineno,
-					 NULL, CNL, FALSE);
+	cmd_len = nih_config_token (file, len, &p, lineno, NULL,
+				    NIH_CONFIG_CNL, FALSE);
 	cmd_end = p;
 
 	if (cmd_len < 0)
 		goto finish;
 
-	/* nih_config_next_token will eat up to the end of the file, a comment
+	/* nih_config_token will eat up to the end of the file, a comment
 	 * or a newline; so this must always succeed.
 	 */
 	if (nih_config_skip_comment (file, len, &p, lineno) < 0)
@@ -632,8 +695,8 @@
 	if (! cmd)
 		nih_return_system_error (NULL);
 
-	if (nih_config_next_token (file + cmd_start, cmd_end - cmd_start, NULL,
-				   NULL, cmd, CNL, FALSE) < 0)
+	if (nih_config_token (file + cmd_start, cmd_end - cmd_start, NULL,
+			      NULL, cmd, NIH_CONFIG_CNL, FALSE) < 0)
 		goto finish;
 
 finish:
@@ -719,7 +782,7 @@
 		line_start = p;
 		if (ws < 0) {
 			/* Count initial whitespace */
-			while ((p < len) && strchr (WS, file[p]))
+			while ((p < len) && strchr (NIH_CONFIG_WS, file[p]))
 				p++;
 
 			ws = p - line_start;
@@ -813,7 +876,7 @@
 	p = *pos;
 
 	/* Skip initial whitespace */
-	while ((p < len) && strchr (WS, file[p]))
+	while ((p < len) && strchr (NIH_CONFIG_WS, file[p]))
 		p++;
 
 	/* Check the first word (check we have at least 4 chars because of
@@ -823,12 +886,12 @@
 		return -1;
 
 	/* Must be whitespace after */
-	if (! strchr (WS, file[p + 3]))
+	if (! strchr (NIH_CONFIG_WS, file[p + 3]))
 		return -1;
 
 	/* Find the second word */
 	p += 3;
-	while ((p < len) && strchr (WS, file[p]))
+	while ((p < len) && strchr (NIH_CONFIG_WS, file[p]))
 		p++;
 
 	/* Check the second word */
@@ -838,7 +901,7 @@
 
 	/* May be followed by whitespace */
 	p += strlen (type);
-	while ((p < len) && strchr (WS, file[p]))
+	while ((p < len) && strchr (NIH_CONFIG_WS, file[p]))
 		p++;
 
 	/* May be a comment, in which case eat up to the newline
@@ -1017,7 +1080,7 @@
 
 	while (p < len) {
 		/* Skip initial whitespace */
-		while ((p < len) && strchr (WS, file[p]))
+		while ((p < len) && strchr (NIH_CONFIG_WS, file[p]))
 			p++;
 
 		/* Skip lines with only comments in them; because has_token

=== modified file 'nih/config.h'
--- nih/config.h	2007-01-22 01:51:17 +0000
+++ nih/config.h	2007-02-11 16:35:38 +0000
@@ -87,51 +87,78 @@
 #define NIH_CONFIG_LAST { NULL, NULL }
 
 
+/**
+ * NIH_CONFIG_WS:
+ *
+ * Definition of what characters we consider whitespace.
+ **/
+#define NIH_CONFIG_WS " \t\r"
+
+/**
+ * NIH_CONFIG_CNL:
+ *
+ * Definition of what characters nominally end a line; a comment start
+ * character or a newline.
+ **/
+#define NIH_CONFIG_CNL "#\n"
+
+/**
+ * NIH_CONFIG_CNLWS:
+ *
+ * Defintion of what characters nominally separate tokens.
+ **/
+#define NIH_CONFIG_CNLWS " \t\r#\n"
+
+
 NIH_BEGIN_EXTERN
 
-int       nih_config_has_token     (const char *file, size_t len, size_t *pos,
-				    size_t *lineno);
-
-ssize_t   nih_config_next_token    (const char *file, size_t len, size_t *pos,
-				    size_t *lineno, char *dest,
-				    const char *delim, int dequote)
-	__attribute__ ((warn_unused_result));
-char *    nih_config_next_arg      (const void *parent,
-				    const char *file, size_t len, size_t *pos,
-				    size_t *lineno)
-	__attribute__ ((warn_unused_result, malloc));
-void      nih_config_next_line     (const char *file, size_t len, size_t *pos,
-				    size_t *lineno);
-int       nih_config_skip_comment  (const char *file, size_t len, size_t *pos,
-				    size_t *lineno)
-	__attribute__ ((warn_unused_result));
-
-char **   nih_config_parse_args    (const void *parent,
-				    const char *file, size_t len, size_t *pos,
-				    size_t *lineno)
-	__attribute__ ((warn_unused_result, malloc));
-char *    nih_config_parse_command (const void *parent,
-				    const char *file, size_t len, size_t *pos,
-				    size_t *lineno)
-	__attribute__ ((warn_unused_result, malloc));
-
-char *    nih_config_parse_block   (const void *parent,
-				    const char *file, size_t len, size_t *pos,
-				    size_t *lineno, const char *type)
-	__attribute__ ((warn_unused_result, malloc));
-
-int       nih_config_parse_stanza  (const char *file, size_t len, size_t *pos,
-				    size_t *lineno, NihConfigStanza *stanzas,
-				    void *data)
-	__attribute__ ((warn_unused_result));
-
-int       nih_config_parse_file    (const char *file, size_t len, size_t *pos,
-				    size_t *lineno, NihConfigStanza *stanzas,
-				    void *data)
-	__attribute__ ((warn_unused_result));
-int       nih_config_parse         (const char *filename,
-				    size_t *pos, size_t *lineno,
-				    NihConfigStanza *stanzas, void *data)
+int       nih_config_has_token       (const char *file, size_t len,
+				      size_t *pos, size_t *lineno);
+
+ssize_t   nih_config_token           (const char *file, size_t len,
+				      size_t *pos, size_t *lineno, char *dest,
+				      const char *delim, int dequote)
+	__attribute__ ((warn_unused_result));
+char *    nih_config_next_token      (const void *parent, const char *file,
+				      size_t len, size_t *pos, size_t *lineno,
+				      const char *delim, int dequote)
+	__attribute__ ((warn_unused_result, malloc));
+char *    nih_config_next_arg        (const void *parent, const char *file,
+				      size_t len, size_t *pos, size_t *lineno)
+	__attribute__ ((warn_unused_result, malloc));
+void      nih_config_next_line       (const char *file, size_t len,
+				      size_t *pos, size_t *lineno);
+
+void      nih_config_skip_whitespace (const char *file, size_t len,
+				      size_t *pos, size_t *lineno);
+int       nih_config_skip_comment    (const char *file, size_t len,
+				      size_t *pos, size_t *lineno)
+	__attribute__ ((warn_unused_result));
+
+char **   nih_config_parse_args      (const void *parent, const char *file,
+				      size_t len, size_t *pos, size_t *lineno)
+	__attribute__ ((warn_unused_result, malloc));
+char *    nih_config_parse_command   (const void *parent, const char *file,
+				      size_t len, size_t *pos, size_t *lineno)
+	__attribute__ ((warn_unused_result, malloc));
+
+char *    nih_config_parse_block     (const void *parent, const char *file,
+				      size_t len, size_t *pos, size_t *lineno,
+				      const char *type)
+	__attribute__ ((warn_unused_result, malloc));
+
+int       nih_config_parse_stanza    (const char *file, size_t len,
+				      size_t *pos, size_t *lineno,
+				      NihConfigStanza *stanzas, void *data)
+	__attribute__ ((warn_unused_result));
+
+int       nih_config_parse_file      (const char *file, size_t len,
+				      size_t *pos, size_t *lineno,
+				      NihConfigStanza *stanzas, void *data)
+	__attribute__ ((warn_unused_result));
+int       nih_config_parse           (const char *filename, size_t *pos,
+				      size_t *lineno, NihConfigStanza *stanzas,
+				      void *data)
 	__attribute__ ((warn_unused_result));
 
 NIH_END_EXTERN

=== modified file 'nih/hash.c'
--- nih/hash.c	2007-02-09 16:46:45 +0000
+++ nih/hash.c	2007-02-11 00:28:30 +0000
@@ -2,7 +2,7 @@
  *
  * hash.c - Fuller/Noll/Vo hash table implementation
  *
- * Copyright © 2006 Scott James Remnant <scott@netsplit.com>.
+ * Copyright © 2007 Scott James Remnant <scott@netsplit.com>.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

=== modified file 'nih/hash.h'
--- nih/hash.h	2007-02-09 17:30:41 +0000
+++ nih/hash.h	2007-02-11 17:00:37 +0000
@@ -72,8 +72,9 @@
  * NIH_HASH_FOREACH_SAFE() instead.
  **/
 #define NIH_HASH_FOREACH(hash, iter) \
-	for (size_t _##iter##_i = 0; _##iter##_i < hash->size; _##iter##_i++) \
-		NIH_LIST_FOREACH (&hash->bins[_##iter##_i], iter)
+	for (size_t _##iter##_i = 0; _##iter##_i < (hash)->size; \
+	     _##iter##_i++) \
+		NIH_LIST_FOREACH (&(hash)->bins[_##iter##_i], iter)
 
 /**
  * NIH_HASH_FOREACH_SAFE:
@@ -94,8 +95,9 @@
  * would need to use NIH_HASH_FOREACH() instead, as this would skip it.
  **/
 #define NIH_HASH_FOREACH_SAFE(hash, iter) \
-	for (size_t _##iter##_i = 0; _##iter##_i < hash->size; _##iter##_i++) \
-		NIH_LIST_FOREACH_SAFE (&hash->bins[_##iter##_i], iter)
+	for (size_t _##iter##_i = 0; _##iter##_i < (hash)->size; \
+	     _##iter##_i++) \
+		NIH_LIST_FOREACH_SAFE (&(hash)->bins[_##iter##_i], iter)
 
 
 NIH_BEGIN_EXTERN

=== modified file 'nih/tests/test_config.c'
--- nih/tests/test_config.c	2007-01-21 11:49:36 +0000
+++ nih/tests/test_config.c	2007-02-11 16:37:48 +0000
@@ -99,14 +99,14 @@
 
 
 void
-test_next_token (void)
+test_token (void)
 {
 	char      buf[1024], dest[1024];
 	size_t    pos, lineno;
 	ssize_t   ret;
 	NihError *err;
 
-	TEST_FUNCTION ("nih_config_next_token");
+	TEST_FUNCTION ("nih_config_token");
 	program_name = "test";
 
 	/* Check that we can obtain the length of the first simple token
@@ -117,8 +117,8 @@
 	strcpy (buf, "this is a test");
 	pos = 0;
 
-	ret = nih_config_next_token (buf, strlen (buf), &pos, NULL,
-				     NULL, " ", FALSE);
+	ret = nih_config_token (buf, strlen (buf), &pos, NULL,
+				NULL, " ", FALSE);
 
 	TEST_EQ (ret, 4);
 	TEST_EQ (pos, 4);
@@ -130,8 +130,8 @@
 	TEST_FEATURE ("with token filling string");
 	strcpy (buf, "wibble");
 	pos = 0;
-	ret = nih_config_next_token (buf, strlen (buf), &pos, NULL,
-				     NULL, " ", FALSE);
+	ret = nih_config_token (buf, strlen (buf), &pos, NULL,
+				NULL, " ", FALSE);
 
 	TEST_EQ (ret, 6);
 	TEST_EQ (pos, 6);
@@ -142,8 +142,8 @@
 	 */
 	TEST_FEATURE ("with token to extract");
 	strcpy (buf, "this is a test");
-	ret = nih_config_next_token (buf, strlen (buf), NULL, NULL,
-				     dest, " ", FALSE);
+	ret = nih_config_token (buf, strlen (buf), NULL, NULL,
+				dest, " ", FALSE);
 
 	TEST_EQ (ret, 4);
 	TEST_EQ_STR (dest, "this");
@@ -154,8 +154,8 @@
 	 */
 	TEST_FEATURE ("with token inside string");
 	pos = 5;
-	ret = nih_config_next_token (buf, strlen (buf), &pos, NULL,
-				     NULL, " ", FALSE);
+	ret = nih_config_token (buf, strlen (buf), &pos, NULL,
+				NULL, " ", FALSE);
 
 	TEST_EQ (ret, 2);
 	TEST_EQ (pos, 7);
@@ -168,8 +168,8 @@
 	TEST_FEATURE ("with double quotes inside token");
 	strcpy (buf, "\"this is a\" test");
 	pos = 0;
-	ret = nih_config_next_token (buf, strlen (buf), &pos, NULL,
-				     NULL, " ", FALSE);
+	ret = nih_config_token (buf, strlen (buf), &pos, NULL,
+				NULL, " ", FALSE);
 
 	TEST_EQ (ret, 11);
 	TEST_EQ (pos, 11);
@@ -179,8 +179,8 @@
 	 * quotes, we should still get those.
 	 */
 	TEST_FEATURE ("with double quotes around token to extract");
-	ret = nih_config_next_token (buf, strlen (buf), NULL, NULL,
-				     dest, " ", FALSE);
+	ret = nih_config_token (buf, strlen (buf), NULL, NULL,
+				dest, " ", FALSE);
 
 	TEST_EQ (ret, 11);
 	TEST_EQ_STR (dest, "\"this is a\"");
@@ -191,8 +191,8 @@
 	 */
 	TEST_FEATURE ("with double quotes and dequoting");
 	pos = 0;
-	ret = nih_config_next_token (buf, strlen (buf), &pos, NULL,
-				     NULL, " ", TRUE);
+	ret = nih_config_token (buf, strlen (buf), &pos, NULL,
+				NULL, " ", TRUE);
 
 	TEST_EQ (ret, 9);
 	TEST_EQ (pos, 11);
@@ -202,8 +202,8 @@
 	 * removed.
 	 */
 	TEST_FEATURE ("with double quotes and extract with dequoting");
-	ret = nih_config_next_token (buf, strlen (buf), NULL, NULL,
-				     dest, " ", TRUE);
+	ret = nih_config_token (buf, strlen (buf), NULL, NULL,
+				dest, " ", TRUE);
 
 	TEST_EQ (ret, 9);
 	TEST_EQ_STR (dest, "this is a");
@@ -216,8 +216,8 @@
 	TEST_FEATURE ("with single quotes inside token");
 	strcpy (buf, "\'this is a\' test");
 	pos = 0;
-	ret = nih_config_next_token (buf, strlen (buf), &pos, NULL,
-				     NULL, " ", FALSE);
+	ret = nih_config_token (buf, strlen (buf), &pos, NULL,
+				NULL, " ", FALSE);
 
 	TEST_EQ (ret, 11);
 	TEST_EQ (pos, 11);
@@ -230,8 +230,8 @@
 	TEST_FEATURE ("with escaped spaces inside token");
 	strcpy (buf, "this\\ is\\ a test");
 	pos = 0;
-	ret = nih_config_next_token (buf, strlen (buf), &pos, NULL,
-				     NULL, " ", FALSE);
+	ret = nih_config_token (buf, strlen (buf), &pos, NULL,
+				NULL, " ", FALSE);
 
 	TEST_EQ (ret, 11);
 	TEST_EQ (pos, 11);
@@ -241,8 +241,8 @@
 	 * around the delimiter.
 	 */
 	TEST_FEATURE ("with escaped spaces within extracted token");
-	ret = nih_config_next_token (buf, strlen (buf), NULL, NULL,
-				     dest, " ", FALSE);
+	ret = nih_config_token (buf, strlen (buf), NULL, NULL,
+				dest, " ", FALSE);
 
 	TEST_EQ (ret, 11);
 	TEST_EQ_STR (dest, "this\\ is\\ a");
@@ -253,8 +253,8 @@
 	 */
 	TEST_FEATURE ("with escaped spaces inside token and dequoting");
 	pos = 0;
-	ret = nih_config_next_token (buf, strlen (buf), &pos, NULL,
-				     NULL, " ", TRUE);
+	ret = nih_config_token (buf, strlen (buf), &pos, NULL,
+				NULL, " ", TRUE);
 
 	TEST_EQ (ret, 9);
 	TEST_EQ (pos, 11);
@@ -264,8 +264,8 @@
 	 * around the delimiter, while removing them.
 	 */
 	TEST_FEATURE ("with escaped spaces within extracted dequoted token");
-	ret = nih_config_next_token (buf, strlen (buf), NULL, NULL,
-				     dest, " ", TRUE);
+	ret = nih_config_token (buf, strlen (buf), NULL, NULL,
+				dest, " ", TRUE);
 
 	TEST_EQ (ret, 9);
 	TEST_EQ_STR (dest, "this is a");
@@ -278,8 +278,8 @@
 	strcpy (buf, "\"this is \n a\" test");
 	pos = 0;
 	lineno = 1;
-	ret = nih_config_next_token (buf, strlen (buf), &pos, &lineno,
-				     NULL, " ", FALSE);
+	ret = nih_config_token (buf, strlen (buf), &pos, &lineno,
+				NULL, " ", FALSE);
 
 	TEST_EQ (ret, 11);
 	TEST_EQ (pos, 13);
@@ -290,8 +290,8 @@
 	 * string only returns a single space for the newline.
 	 */
 	TEST_FEATURE ("with newline inside extracted quoted string");
-	ret = nih_config_next_token (buf, strlen (buf), NULL, NULL,
-				     dest, " ", FALSE);
+	ret = nih_config_token (buf, strlen (buf), NULL, NULL,
+				dest, " ", FALSE);
 
 	TEST_EQ (ret, 11);
 	TEST_EQ_STR (dest, "\"this is a\"");
@@ -303,8 +303,8 @@
 	TEST_FEATURE ("with newline inside quoted string and lineno set");
 	pos = 0;
 	lineno = 1;
-	ret = nih_config_next_token (buf, strlen (buf), &pos, &lineno,
-				     NULL, " ", FALSE);
+	ret = nih_config_token (buf, strlen (buf), &pos, &lineno,
+				NULL, " ", FALSE);
 
 	TEST_EQ (ret, 11);
 	TEST_EQ (pos, 13);
@@ -318,8 +318,8 @@
 	strcpy (buf, "this \\\n is a:test");
 	pos = 0;
 	lineno = 1;
-	ret = nih_config_next_token (buf, strlen (buf), &pos, &lineno,
-				     NULL, ":", FALSE);
+	ret = nih_config_token (buf, strlen (buf), &pos, &lineno,
+				NULL, ":", FALSE);
 
 	TEST_EQ (ret, 9);
 	TEST_EQ (pos, 12);
@@ -330,8 +330,8 @@
 	 * returns a single space for the newline.
 	 */
 	TEST_FEATURE ("with escaped newline inside extracted string");
-	ret = nih_config_next_token (buf, strlen (buf), NULL, NULL,
-				     dest, ":", FALSE);
+	ret = nih_config_token (buf, strlen (buf), NULL, NULL,
+				dest, ":", FALSE);
 
 	TEST_EQ (ret, 9);
 	TEST_EQ_STR (dest, "this is a");
@@ -343,8 +343,8 @@
 	TEST_FEATURE ("with escaped newline inside string and lineno set");
 	pos = 0;
 	lineno = 1;
-	ret = nih_config_next_token (buf, strlen (buf), &pos, &lineno,
-				     NULL, ":", FALSE);
+	ret = nih_config_token (buf, strlen (buf), &pos, &lineno,
+				NULL, ":", FALSE);
 
 	TEST_EQ (ret, 9);
 	TEST_EQ (pos, 12);
@@ -359,8 +359,8 @@
 	pos = 0;
 	lineno = 1;
 
-	ret = nih_config_next_token (buf, strlen (buf), &pos, &lineno,
-				     NULL, " ", FALSE);
+	ret = nih_config_token (buf, strlen (buf), &pos, &lineno,
+				NULL, " ", FALSE);
 
 	TEST_LT (ret, 0);
 	TEST_EQ (pos, 7);
@@ -379,8 +379,8 @@
 	pos = 0;
 	lineno = 1;
 
-	ret = nih_config_next_token (buf, strlen (buf), &pos, &lineno,
-				     NULL, " ", FALSE);
+	ret = nih_config_token (buf, strlen (buf), &pos, &lineno,
+				NULL, " ", FALSE);
 
 	TEST_LT (ret, 0);
 	TEST_EQ (pos, 8);
@@ -397,14 +397,281 @@
 	TEST_FEATURE ("with empty token");
 	strcpy (buf, " wibble");
 	pos = 0;
-	ret = nih_config_next_token (buf, strlen (buf), &pos, NULL,
-				     NULL, " ", FALSE);
+	ret = nih_config_token (buf, strlen (buf), &pos, NULL,
+				NULL, " ", FALSE);
 
 	TEST_EQ (ret, 0);
 	TEST_EQ (pos, 0);
 }
 
 void
+test_next_token (void)
+{
+	char      buf[1024];
+	char     *str;
+	size_t    pos, lineno;
+	NihError *err;
+
+	TEST_FUNCTION ("nih_config_next_token");
+
+	/* Check that we can extract a token at the start of a string,
+	 * and have the position pointing past the whitespace to the next
+	 * argument.
+	 */
+	TEST_FEATURE ("with token at start of string");
+	TEST_ALLOC_FAIL {
+		strcpy (buf, "this is a test");
+		pos = 0;
+
+		str = nih_config_next_token (NULL, buf,
+					     strlen (buf), &pos, NULL,
+					     NIH_CONFIG_CNLWS, FALSE);
+
+		if (test_alloc_failed) {
+			TEST_EQ_P (str, NULL);
+			TEST_EQ (pos, 0);
+
+			err = nih_error_get ();
+			TEST_EQ (err->number, ENOMEM);
+			nih_free (err);
+			continue;
+		}
+
+		TEST_EQ (pos, 5);
+		TEST_ALLOC_SIZE (str, 5);
+		TEST_EQ_STR (str, "this");
+
+		nih_free (str);
+	}
+
+
+	/* Check that we can extract an argument inside a string
+	 */
+	TEST_FEATURE ("with token inside string");
+	TEST_ALLOC_FAIL {
+		strcpy (buf, "this is a test");
+		pos = 5;
+
+		str = nih_config_next_token (NULL, buf,
+					     strlen (buf), &pos, NULL,
+					     NIH_CONFIG_CNLWS, FALSE);
+
+		if (test_alloc_failed) {
+			TEST_EQ_P (str, NULL);
+			TEST_EQ (pos, 5);
+
+			err = nih_error_get ();
+			TEST_EQ (err->number, ENOMEM);
+			nih_free (err);
+			continue;
+		}
+
+		TEST_EQ (pos, 8);
+		TEST_ALLOC_SIZE (str, 3);
+		TEST_EQ_STR (str, "is");
+
+		nih_free (str);
+	}
+
+
+	/* Check that all trailing whitespace is eaten after the token. */
+	TEST_FEATURE ("with consecutive whitespace after token");
+	TEST_ALLOC_FAIL {
+		strcpy (buf, "this \t  is a test");
+		pos = 0;
+
+		str = nih_config_next_token (NULL, buf,
+					     strlen (buf), &pos, NULL,
+					     NIH_CONFIG_CNLWS, FALSE);
+
+		if (test_alloc_failed) {
+			TEST_EQ_P (str, NULL);
+			TEST_EQ (pos, 0);
+
+			err = nih_error_get ();
+			TEST_EQ (err->number, ENOMEM);
+			nih_free (err);
+			continue;
+		}
+
+		TEST_EQ (pos, 8);
+		TEST_ALLOC_SIZE (str, 5);
+		TEST_EQ_STR (str, "this");
+
+		nih_free (str);
+	}
+
+
+	/* Check that any escaped newlines in the whitespace are skipped
+	 * over
+	 */
+	TEST_FEATURE ("with escaped newlines in whitespace");
+	TEST_ALLOC_FAIL {
+		strcpy (buf, "this \\\n is a test");
+		pos = 0;
+
+		str = nih_config_next_token (NULL, buf,
+					     strlen (buf), &pos, NULL,
+					     NIH_CONFIG_CNLWS, FALSE);
+
+		if (test_alloc_failed) {
+			TEST_EQ_P (str, NULL);
+			TEST_EQ (pos, 0);
+
+			err = nih_error_get ();
+			TEST_EQ (err->number, ENOMEM);
+			nih_free (err);
+			continue;
+		}
+
+		TEST_EQ (pos, 8);
+		TEST_ALLOC_SIZE (str, 5);
+		TEST_EQ_STR (str, "this");
+
+		nih_free (str);
+	}
+
+
+	/* Check that the line number is incremented for any escaped newlines
+	 * in the whitespace.
+	 */
+	TEST_FEATURE ("with line number set");
+	TEST_ALLOC_FAIL {
+		pos = 0;
+		lineno = 1;
+
+		str = nih_config_next_token (NULL, buf,
+					     strlen (buf), &pos, &lineno,
+					     NIH_CONFIG_CNLWS, FALSE);
+
+		if (test_alloc_failed) {
+			TEST_EQ_P (str, NULL);
+			TEST_EQ (pos, 0);
+			TEST_EQ (lineno, 2);
+
+			err = nih_error_get ();
+			TEST_EQ (err->number, ENOMEM);
+			nih_free (err);
+			continue;
+		}
+
+		TEST_EQ (pos, 8);
+		TEST_EQ (lineno, 2);
+		TEST_ALLOC_SIZE (str, 5);
+		TEST_EQ_STR (str, "this");
+
+		nih_free (str);
+	}
+
+
+	/* Check that the returned token can have the quotes left in it,
+	 * but the whitespace around the newline collapsed.
+	 */
+	TEST_FEATURE ("with token containing quotes");
+	TEST_ALLOC_FAIL {
+		strcpy (buf, "\"this \\\n is\" a test");
+		pos = 0;
+
+		str = nih_config_next_token (NULL, buf,
+					     strlen (buf), &pos, NULL,
+					     NIH_CONFIG_CNLWS, FALSE);
+
+		if (test_alloc_failed) {
+			TEST_EQ_P (str, NULL);
+			TEST_EQ (pos, 0);
+
+			err = nih_error_get ();
+			TEST_EQ (err->number, ENOMEM);
+			nih_free (err);
+			continue;
+		}
+
+		TEST_EQ (pos, 13);
+		TEST_ALLOC_SIZE (str, 10);
+		TEST_EQ_STR (str, "\"this is\"");
+
+		nih_free (str);
+	}
+
+
+	/* Check that the returned token can be thoroughly dequoted and any
+	 * whitespace around an embedded newline collapsed to a single
+	 * space.
+	 */
+	TEST_FEATURE ("with quoted whitespace and newline in token");
+	TEST_ALLOC_FAIL {
+		strcpy (buf, "\"this \\\n is\" a test");
+		pos = 0;
+
+		str = nih_config_next_token (NULL, buf,
+					     strlen (buf), &pos, NULL,
+					     NIH_CONFIG_CNLWS, TRUE);
+
+		if (test_alloc_failed) {
+			TEST_EQ_P (str, NULL);
+			TEST_EQ (pos, 0);
+
+			err = nih_error_get ();
+			TEST_EQ (err->number, ENOMEM);
+			nih_free (err);
+			continue;
+		}
+
+		TEST_EQ (pos, 13);
+		TEST_ALLOC_SIZE (str, 8);
+		TEST_EQ_STR (str, "this is");
+
+		nih_free (str);
+	}
+
+
+	/* Check that an error is raised if there is no token at that
+	 * position.
+	 */
+	TEST_FEATURE ("with empty line");
+	TEST_ALLOC_FAIL {
+		strcpy (buf, "\nthis is a test");
+		pos = 0;
+		lineno = 1;
+
+		str = nih_config_next_token (NULL, buf,
+					     strlen (buf), &pos, &lineno,
+					     NIH_CONFIG_CNLWS, FALSE);
+
+		TEST_EQ_P (str, NULL);
+		TEST_EQ (pos, 0);
+		TEST_EQ (lineno, 1);
+
+		err = nih_error_get ();
+		TEST_EQ (err->number, NIH_CONFIG_EXPECTED_TOKEN);
+		nih_free (err);
+	}
+
+
+	/* Check that a parse error being found with the argument causes an
+	 * error to be raised, with pos and lineno at the site of the error.
+	 */
+	TEST_FEATURE ("with parser error");
+	TEST_ALLOC_FAIL {
+		strcpy (buf, "\"this is a test\nand so is this");
+		pos = 0;
+		lineno = 1;
+
+		str = nih_config_next_token (NULL, buf,
+					     strlen (buf), &pos, &lineno,
+					     NIH_CONFIG_CNLWS, FALSE);
+
+		TEST_EQ_P (str, NULL);
+		TEST_EQ (pos, 30);
+		TEST_EQ (lineno, 2);
+
+		err = nih_error_get ();
+		TEST_EQ (err->number, NIH_CONFIG_UNTERMINATED_QUOTE);
+		nih_free (err);
+	}
+}
+
+void
 test_next_arg (void)
 {
 	char      buf[1024];
@@ -691,6 +958,70 @@
 }
 
 void
+test_skip_whitespace (void)
+{
+	char   buf[1024];
+	size_t pos, lineno;
+
+	TEST_FUNCTION ("nih_config_next_whitespace");
+
+	/* Check that we can skip an amount of plain whitespace characters
+	 * until the next token, pointing pos at is.
+	 */
+	TEST_FEATURE ("with plain whitespace");
+	strcpy (buf, "a  plain string\n");
+	pos = 1;
+	lineno = 1;
+
+	nih_config_skip_whitespace (buf, strlen (buf), &pos, &lineno);
+
+	TEST_EQ (pos, 3);
+	TEST_EQ (lineno, 1);
+
+
+	/* Check that we can skip a more complex series of whitespace
+	 * characters until the next token.
+	 */
+	TEST_FEATURE ("with complex whitespace");
+	strcpy (buf, "a more   \t  \r  complex string\n");
+	pos = 6;
+	lineno = 1;
+
+	nih_config_skip_whitespace (buf, strlen (buf), &pos, &lineno);
+
+	TEST_EQ (pos, 15);
+	TEST_EQ (lineno, 1);
+
+
+	/* Check that we can skip whitespace characters up until the end
+	 * of the line, but that we don't step over it.
+	 */
+	TEST_FEATURE ("with whitespace at end of line");
+	strcpy (buf, "trailing whitespace  \t\r\n");
+	pos = 19;
+	lineno = 1;
+
+	nih_config_skip_whitespace (buf, strlen (buf), &pos, &lineno);
+
+	TEST_EQ (pos, 23);
+	TEST_EQ (lineno, 1);
+
+
+	/* Check that we step over an escaped newline embedded in the
+	 * whitespace, and increment lineno.
+	 */
+	TEST_FEATURE ("with escaped newline");
+	strcpy (buf, "this has \\\n a newline");
+	pos = 8;
+	lineno = 1;
+
+	nih_config_skip_whitespace (buf, strlen (buf), &pos, &lineno);
+
+	TEST_EQ (pos, 12);
+	TEST_EQ (lineno, 2);
+}
+
+void
 test_skip_comment (void)
 {
 	char      buf[1024];
@@ -2306,9 +2637,11 @@
       char *argv[])
 {
 	test_has_token ();
+	test_token ();
 	test_next_token ();
 	test_next_arg ();
 	test_next_line ();
+	test_skip_whitespace ();
 	test_skip_comment ();
 	test_parse_args ();
 	test_parse_command ();

