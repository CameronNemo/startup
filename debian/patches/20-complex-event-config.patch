=== modified file 'init/cfgfile.c'
--- init/cfgfile.c	2007-02-11 14:18:00 +0000
+++ init/cfgfile.c	2007-02-12 12:39:36 +0000
@@ -57,6 +57,12 @@
 #include "errors.h"
 
 
+typedef struct stack_item {
+	NihList      entry;
+	JobOperator *oper;
+} StackItem;
+
+
 /* Prototypes for static functions */
 static int   cfg_stanza_description    (Job *job, NihConfigStanza *stanza,
 					const char *file, size_t len,
@@ -495,6 +501,288 @@
 	return 0;
 }
 
+
+/**
+ * _operator_prec:
+ * @item: stack item to examine.
+ *
+ * This function ranks the operators for the "on" stanza by precedence;
+ * "and" and "or" have equal precedence and "until" has a higher
+ * precedence.
+ *
+ * This also deals with the special cases of a parenthesis, which has a
+ * zero precedence, so nothing may pop it from the stack except a close
+ * paren, and of an Event being constructed on the operator stack which
+ * has a higher precedence than any operator so that everything pops it
+ * off the stack.
+ *
+ * Returns: precedence of @item.
+ **/
+static int
+_operator_prec (StackItem *item)
+{
+	nih_assert (item != NULL);
+
+	if (! item->oper)
+		return 0;
+
+	switch (item->oper->type) {
+	case JOB_OPER_AND:
+	case JOB_OPER_OR:
+		return 1;
+	case JOB_OPER_UNTIL:
+		return 2;
+	case JOB_OPER_EVENT:
+		return 3;
+	default:
+		nih_assert_not_reached ();
+	}
+}
+
+/**
+ * _operator_pop:
+ * @op_stack: operator stack
+ * @out_stack: output stack.
+ *
+ * Removes the top operator from the @op_stack, read its arguments from the
+ * @out_stack and stores them in the operator and then pushes the complete
+ * operator structure onto the @out_stack.
+ *
+ * Returns: zero on success, negative value on raised error.
+ **/
+static int
+_operator_pop (NihList *op_stack,
+	       NihList *out_stack)
+{
+	StackItem *item;
+
+	nih_assert (op_stack != NULL);
+	nih_assert (out_stack != NULL);
+	nih_assert (! NIH_LIST_EMPTY (op_stack));
+
+	/* We take the item from the top of the operator stack, collect its
+	 * arguments (if any) from the output stack, reparent them to belong
+	 * to the operator item, and place the entire thing on the output
+	 * stack.
+	 */
+	item = (StackItem *)op_stack->next;
+
+	if (item->oper->type == JOB_OPER_EVENT) {
+		/* Nothing to do for events, they're already complete
+		 * by the time we pop them.
+		 */
+
+	} else {
+		int i;
+
+		/* All other operators have two arguments. */
+		for (i = 0; i < 2; i++) {
+			StackItem *arg_item;
+
+			if (NIH_LIST_EMPTY (out_stack))
+				nih_return_error (-1, NIH_CONFIG_EXPECTED_TOKEN,
+						  _(NIH_CONFIG_EXPECTED_TOKEN_STR));
+
+			arg_item = (StackItem *)out_stack->next;
+
+			item->oper->child[1 - i] = arg_item->oper;
+			arg_item->oper->parent = item->oper;
+
+			nih_alloc_reparent (arg_item->oper, item->oper);
+			nih_list_free (&arg_item->entry);
+		}
+	}
+
+	nih_list_add_after (out_stack, &item->entry);
+
+	return 0;
+}
+
+static int
+cfg_stanza_on_token (Job        *job,
+		     const char *file,
+		     size_t      len,
+		     size_t     *pos,
+		     size_t     *lineno,
+		     NihList    *op_stack,
+		     NihList    *out_stack,
+		     int        *paren)
+{
+	StackItem       *item;
+	JobOperatorType  type;
+	char            *arg;
+	size_t           arg_pos, arg_lineno;
+
+	nih_assert (job != NULL);
+	nih_assert (file != NULL);
+	nih_assert (pos != NULL);
+	nih_assert (op_stack != NULL);
+	nih_assert (out_stack != NULL);
+	nih_assert (paren != NULL);
+
+	if (job->on)
+		nih_return_error (-1, CFG_DUPLICATE_VALUE,
+				  _(CFG_DUPLICATE_VALUE_STR));
+
+	/* First we peek at the first character of the input stream, since
+	 * it might be an open or close parenthesis, and those aren't caught
+	 * by the ordinary tokeniser.
+	 */
+	if ((*pos < len) && (file[*pos] == '(')) {
+		(*paren)++;
+
+		/* Skip over the paren, and any following whitespace */
+		(*pos)++;
+		nih_config_skip_whitespace (file, len, pos, lineno);
+
+		/* Push a NULL item onto the operator stack, the marker we
+		 * use for a parenthesis; no need to pop anything off.
+		 */
+		NIH_MUST (item = nih_new (job, StackItem));
+
+		nih_list_init (&item->entry);
+		item->oper = NULL;
+
+		nih_list_add_after (op_stack, &item->entry);
+
+		return 0;
+	} else if ((*pos < len) && (file[*pos] == ')')) {
+		(*paren)--;
+
+		/* Skip over the paren, and any following whitespace */
+		(*pos)++;
+		nih_config_skip_whitespace (file, len, pos, lineno);
+
+		/* Pop all items from the operator stack until we find a
+		 * NULL item, which is our matching open paren.
+		 */
+		while ((! NIH_LIST_EMPTY (op_stack))
+		       && ((StackItem *)op_stack->next)->oper)
+			if (_operator_pop (op_stack, out_stack) < 0)
+				return -1;
+
+		if (NIH_LIST_EMPTY (op_stack))
+			nih_return_error (-1, CFG_MISMATCHED_PARENS,
+					  _(CFG_MISMATCHED_PARENS_STR));
+
+		/* The next item must be the paren we found, simply remove
+		 * it from the operator stack and discard.
+		 */
+		nih_list_free (&((StackItem *)op_stack->next)->entry);
+
+		return 0;
+	}
+
+
+
+	/* Next we peek at the entire next token to see whether it's an
+	 * operator keyword that we recognise.  We don't dequote these since
+	 * this allows people to quote them to make them not-operators.
+	 */
+	arg_pos = *pos;
+	if (lineno)
+		arg_lineno = *lineno;
+
+	arg = nih_config_next_token (NULL, file, len, &arg_pos, &arg_lineno,
+				     "()" NIH_CONFIG_CNLWS, FALSE);
+	if (! arg)
+		return 1;
+
+	if (! strcmp (arg, "and")) {
+		type = JOB_OPER_AND;
+
+	} else if (! strcmp (arg, "or")) {
+		type = JOB_OPER_OR;
+
+	} else if (! strcmp (arg, "until")) {
+		type = JOB_OPER_UNTIL;
+
+	} else {
+		nih_free (arg);
+
+		/* It's not an operator; look at the item on the top of the
+		 * operator stack -- if it's an Event, then we've got an
+		 * argument to it; otherwise we need to create an Event.
+		 */
+		item = (StackItem *)op_stack->next;
+		if (NIH_LIST_EMPTY (op_stack)
+		    || (! item->oper)
+		    || (item->oper->type != JOB_OPER_EVENT))
+		{
+			arg = nih_config_next_token (
+				NULL, file, len, pos, lineno,
+				"()" NIH_CONFIG_CNLWS, TRUE);
+			if (! arg)
+				return -1;
+
+			NIH_MUST (item = nih_new (job, StackItem));
+			NIH_MUST (item->oper = nih_new (item, JobOperator));
+
+			nih_list_init (&item->entry);
+			item->oper->parent = NULL;
+			item->oper->type = JOB_OPER_EVENT;
+			item->oper->value = FALSE;
+
+			NIH_MUST (item->oper->event = event_new (item->oper, arg));
+
+			nih_free (arg);
+
+			nih_list_add_after (op_stack, &item->entry);
+		} else {
+			arg = nih_config_next_token (
+				NULL, file, len, pos, lineno,
+				"()" NIH_CONFIG_CNLWS, TRUE);
+			if (! arg)
+				return -1;
+
+			NIH_MUST (nih_str_array_addp (
+					  &item->oper->event->args,
+					  item->oper->event, NULL, arg));
+		}
+
+		return 0;
+	}
+
+
+	/* We found an operator, first we need to take the token from the
+	 * input stream.
+	 */
+	nih_free (arg);
+	*pos = arg_pos;
+	if (lineno)
+		*lineno = arg_lineno;
+
+	/* Now we allocate the stack item for it using the type we've set. */
+	NIH_MUST (item = nih_new (job, StackItem));
+	NIH_MUST (item->oper = nih_new (item, JobOperator));
+
+	nih_list_init (&item->entry);
+	item->oper->parent = NULL;
+	item->oper->type = type;
+	item->oper->value = FALSE;
+	item->oper->child[0] = NULL;
+	item->oper->child[1] = NULL;
+
+	/* Before we push the operator onto the stack, we need to pop any
+	 * operators with a higher equal precedence and push them onto the
+	 * output stack (which will consume their arguments).
+	 *
+	 * We're getting away with being simpler here since all our
+	 * operators are left-associative; if they weren't, we'd also have
+	 * to check for equal precedence.
+	 */
+	while ((! NIH_LIST_EMPTY (op_stack))
+	       && (_operator_prec (item)
+		   <= _operator_prec ((StackItem *)op_stack->next)))
+		if (_operator_pop (op_stack, out_stack) < 0)
+			return -1;
+
+	/* Now push the item onto the operator stack */
+	nih_list_add_after (op_stack, &item->entry);
+
+	return 0;
+}
+
 /**
  * cfg_stanza_on:
  * @job: job being parsed,
@@ -504,8 +792,12 @@
  * @pos: offset within @file,
  * @lineno: line number.
  *
- * Parse an on stanza from @file, extracting a single argument containing
- * an event that starts the job, followed by arguments for that event.
+ * Parse an on stanza from @file, this is the most complex configuration
+ * stanza in the job definition since it defines the state in which a job
+ * should be running.
+ *
+ * The arguments are parsed into a tree of operators and operands to them,
+ * usually events (except for "with" which accepts a job name).
  *
  * Returns: zero on success, negative value on error.
  **/
@@ -517,32 +809,80 @@
 	       size_t          *pos,
 	       size_t          *lineno)
 {
-	Event *event;
-	char  *name;
+	NihList    op_stack, out_stack;
+	StackItem *item;
+	int        paren = 0;
 
 	nih_assert (job != NULL);
 	nih_assert (stanza != NULL);
 	nih_assert (file != NULL);
 	nih_assert (pos != NULL);
 
-	name = nih_config_next_arg (NULL, file, len, pos, lineno);
-	if (! name)
-		return -1;
-
-	NIH_MUST (event = event_new (job, name));
-	nih_free (name);
-
-	event->args = nih_config_parse_args (event, file, len, pos, lineno);
-	if (! event->args) {
-		nih_free (event);
-		return -1;
-	}
-
-	nih_list_add (&job->start_events, &event->entry);
+	nih_list_init (&op_stack);
+	nih_list_init (&out_stack);
+
+	/* Parse all tokens we find in the configuration stanza; unlike
+	 * other stanzas, we happily parse multiple lines provided we're
+	 * inside parens and permit comments at the end of those lines.
+	 */
+	do {
+		nih_config_skip_whitespace (file, len, pos, lineno);
+
+		do {
+			if (cfg_stanza_on_token (job, file, len, pos, lineno,
+						 &op_stack, &out_stack,
+						 &paren) < 0)
+				return -1;
+		} while (nih_config_has_token (file, len, pos, lineno));
+
+		if (nih_config_skip_comment (file, len, pos, lineno) < 0)
+			return -1;
+	} while ((*pos < len) && paren);
+
+	/* If we have any parens in the stack, then we probably just parsed
+	 * the entire file by accident.
+	 */
+	if (paren)
+		nih_return_error (-1, CFG_MISMATCHED_PARENS,
+				  _(CFG_MISMATCHED_PARENS_STR));
+
+	/* We probably have a few operators left on the operator stack, so
+	 * pop those now which should also consume the output stack.
+	 */
+	while (! NIH_LIST_EMPTY (&op_stack))
+		if (_operator_pop (&op_stack, &out_stack) < 0)
+			return -1;
+
+
+	/* If we don't have anything in the output stack now, somebody's
+	 * just given us a bunch of parens and whitespace to parse.
+	 */
+	if (NIH_LIST_EMPTY (&out_stack))
+		nih_return_error (-1, NIH_CONFIG_EXPECTED_TOKEN,
+				  _(NIH_CONFIG_EXPECTED_TOKEN_STR));
+
+	/* Take the item from the top of the output stack and place it
+	 * in the job as the top of the parse tree.
+	 */
+	item = (StackItem *)out_stack.next;
+
+	nih_alloc_reparent (item->oper, job);
+	job->on = item->oper;
+
+	nih_list_free (&item->entry);
+
+
+	/* Make sure that there's nothing left in the output stack, caused
+	 * by missing an operator out.
+	 */
+	if (! NIH_LIST_EMPTY (&out_stack))
+		nih_return_error (-1, NIH_CONFIG_EXPECTED_TOKEN,
+				  _(NIH_CONFIG_EXPECTED_TOKEN_STR));
 
 	return 0;
 }
 
+
 /**
  * cfg_stanza_start:
  * @job: job being parsed,

=== modified file 'init/errors.h'
--- init/errors.h	2007-01-09 15:47:24 +0000
+++ init/errors.h	2007-02-12 03:20:47 +0000
@@ -32,10 +32,12 @@
 	/* Errors while parsing configuration files */
 	CFG_ILLEGAL_VALUE,
 	CFG_DUPLICATE_VALUE,
+	CFG_MISMATCHED_PARENS,
 };
 
 /* Error strings for defined messages */
 #define CFG_ILLEGAL_VALUE_STR           N_("Illegal value")
 #define CFG_DUPLICATE_VALUE_STR		N_("Duplicate value")
+#define CFG_MISMATCHED_PARENS_STR	N_("Mismatched parens")
 
 #endif /* INIT_ERRORS_H */

=== modified file 'init/job.c'
--- init/job.c	2007-02-11 18:20:19 +0000
+++ init/job.c	2007-02-12 13:09:37 +0000
@@ -157,6 +157,8 @@
 	job->failed_state = JOB_WAITING;
 	job->exit_status = 0;
 
+	job->on = NULL;
+
 	nih_list_init (&job->start_events);
 	nih_list_init (&job->stop_events);
 	nih_list_init (&job->emits);
@@ -204,6 +206,31 @@
 	return job;
 }
 
+static JobOperator *
+job_copy_oper (const void        *parent,
+	       const JobOperator *old_oper)
+{
+	JobOperator *oper;
+
+	NIH_MUST (oper = nih_new (parent, JobOperator));
+
+	oper->parent = NULL;
+	oper->type = old_oper->type;
+	oper->value = FALSE;
+
+	if (oper->type == JOB_OPER_EVENT) {
+		NIH_MUST (oper->event = event_copy (oper, old_oper->event));
+	} else {
+		NIH_MUST (oper->child[0] = job_copy_oper (oper, old_oper->child[0]));
+		NIH_MUST (oper->child[1] = job_copy_oper (oper, old_oper->child[1]));
+
+		oper->child[0]->parent = oper;
+		oper->child[1]->parent = oper;
+	}
+
+	return oper;
+}
+
 /**
  * job_copy:
  * @parent: parent of new job,
@@ -253,6 +280,9 @@
 			goto error;
 	}
 
+	if (old_job->on)
+		job->on = job_copy_oper (job, job->on);
+
 	NIH_LIST_FOREACH (&old_job->start_events, iter) {
 		Event *old_event = (Event *)iter;
 		Event *event;
@@ -1480,6 +1510,61 @@
 }
 
 
+static void
+job_on_change (Job           *job,
+	       JobOperator   *oper,
+	       JobOperator   *child,
+	       int           *change)
+{
+	if (oper->type == JOB_OPER_EVENT) {
+		oper->value = TRUE;
+
+	} else if (oper->type == JOB_OPER_AND) {
+		if (oper->child[0]->value && oper->child[1]->value) {
+			oper->value = TRUE;
+		} else {
+			oper->value = FALSE;
+		}
+
+	} else if (oper->type == JOB_OPER_OR) {
+		if (oper->child[0]->value || oper->child[1]->value) {
+			oper->value = TRUE;
+		} else {
+			oper->value = FALSE;
+		}
+
+	} else if (oper->type == JOB_OPER_UNTIL) {
+		if (child == oper->child[0]) {
+			oper->value = TRUE;
+		} else if (child == oper->child[1]) {
+			oper->value = FALSE;
+		}
+	}
+
+	if (oper->parent) {
+		job_on_change (job, oper->parent, oper, change);
+	} else {
+		*change = TRUE;
+	}
+}
+
+static void
+job_on_event (Job           *job,
+	      JobOperator   *oper,
+	      EventEmission *emission,
+	      int           *change)
+{
+	if (oper->type != JOB_OPER_EVENT)
+		job_on_event (job, oper->child[0], emission, change);
+
+	if (oper->type == JOB_OPER_EVENT)
+		if (event_match (&emission->event, oper->event))
+			job_on_change (job, oper, NULL, change);
+
+	if (oper->type != JOB_OPER_EVENT)
+		job_on_event (job, oper->child[1], emission, change);
+}
+
 /**
  * job_handle_event:
  * @emission: event emission to be handled.
@@ -1514,6 +1599,19 @@
 				job_change_goal (job, JOB_STOP, emission);
 		}
 
+		if (job->on) {
+			int change = FALSE;
+
+			job_on_event (job, job->on, emission, &change);
+
+			if (change && job->on->value) {
+				job_change_goal (job, JOB_START, emission);
+			} else if (change) {
+				job_change_goal (job, JOB_STOP, emission);
+			}
+		}
+
+
 		NIH_LIST_FOREACH (&job->start_events, iter) {
 			Event *start_event = (Event *)iter;
 

=== modified file 'init/job.h'
--- init/job.h	2007-02-10 14:15:47 +0000
+++ init/job.h	2007-02-12 03:18:35 +0000
@@ -78,6 +78,25 @@
 #define JOB_DEFAULT_UMASK 022
 
 
+typedef enum {
+	JOB_OPER_EVENT,
+	JOB_OPER_AND,
+	JOB_OPER_OR,
+	JOB_OPER_UNTIL,
+} JobOperatorType;
+
+typedef struct job_operator JobOperator;
+struct job_operator {
+	JobOperator     *parent;
+	JobOperatorType  type;
+	int              value;
+
+	union {
+		Event       *event;
+		JobOperator *child[2];
+	};
+};
+
 /**
  * JobProcess:
  * @script: whether a shell will be required,
@@ -175,6 +194,8 @@
 	JobState       failed_state;
 	int            exit_status;
 
+	JobOperator   *on;
+
 	NihList        start_events;
 	NihList        stop_events;
 	NihList        emits;

